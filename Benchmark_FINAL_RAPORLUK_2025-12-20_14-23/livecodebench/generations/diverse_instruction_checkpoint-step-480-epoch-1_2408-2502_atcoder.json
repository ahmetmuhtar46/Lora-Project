[
  {
    "question_id": "abc365_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    # Sort the array to find the second largest\n    sorted_A = sorted(A)\n    print(sorted_A[-2])\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc365_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    Y = int(data)\n    \n    # Check for leap year conditions\n    if (Y % 4 == 0 and Y % 100 != 0) or (Y % 400 == 0):\n        print(366)\n    else:\n        print(365)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    n = int(data[0])\n    \n    # Read all strings\n    strings = []\n    for i in range(1, 1 + n):\n        strings.append(data[i].strip())\n    \n    # Find maximum length\n    max_len = max(len(s) for s in strings)\n    \n    # Create result matrix\n    result = [['' for _ in range(max_len)] for _ in range(n)]\n    \n    # Fill first column\n    for i in range(n):\n        result[i][0] = strings[i][0]\n    \n    # Fill remaining columns\n    for j in range(1, max_len):\n        for i in range(n):\n            if j < len(strings[i]):\n                result[i][j] = strings[i][j]\n            else:\n                # If current string doesn't have enough characters, use *\n                result[i][j] = '*'\n    \n    # Print results\n    for row in result:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc366_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    T = int(data[1])\n    A = int(data[2])\n    \n    if (T + A) % 2 == 0:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    A = int(data[0])\n    B = int(data[1])\n    C = int(data[2])\n    \n    # Check if there's any hour where he's awake and asleep simultaneously\n    if max(A, B) <= min(C, B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc367_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    # Remove trailing zeros and check for unnecessary decimal point\n    while len(data) > 1 and data[-1] == '0':\n        data = data[:-1]\n    \n    # If we removed all digits, output 0\n    if not data:\n        print(\"0\")\n    else:\n        print(data)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    # Read the stack from bottom to top (index 2)\n    stack = list(map(int, data[2:2+n]))\n    \n    # Take last k elements and put at beginning\n    result = stack[-k:] + stack[:-k]\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc368_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    A = list(map(int, data[1:1+N]))\n    \n    # Calculate initial sum\n    S = sum(A)\n    \n    # Count the number of operations\n    k = 0\n    current_sum = S\n    \n    while current_sum > 0:\n        k += 1\n        current_sum -= 2\n        \n    print(k)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc369_a",
    "code_list": [
      "def count_valid_x(A, B):\n    count = 0\n    \n    # Check all permutations of (A, B, C)\n    for a in range(1, 101):\n        for b in range(1, 101):\n            for c in range(1, 101):\n                # Check all six cases\n                if (b == a + c or \n                    a == b + c or \n                    b == c + a or \n                    c == a + b or \n                    a == b + c or \n                    b == a + c):\n                    count += 1\n                    \n    return count\n\n# Read input\nimport sys\ndata = sys.stdin.read().split()\nif len(data) >= 2:\n    A = int(data[0])\n    B = int(data[1])\n    result = count_valid_x(A, B)\nelse:\n    result = 0\n    \nprint(result)"
    ]
  },
  {
    "question_id": "abc369_b",
    "code_list": [
      "def min_fatigue(N, A, S):\n    # Initialize positions\n    pos_left = 1  # Both hands start on key 1\n    pos_right = 1\n    \n    total_distance = 0\n    \n    for i in range(N):\n        # Determine direction based on S_i\n        if S[i] == 'L':\n            # Move left\n            if pos_left > A[i]:\n                total_distance += (pos_left - A[i])\n                pos_left = A[i]\n            else:\n                total_distance += (A[i] - pos_left)\n                pos_left = A[i]\n        else:  # S_i == 'R'\n            # Move right\n            if pos_right < A[i]:\n                total_distance += (A[i] - pos_right)\n                pos_right = A[i]\n            else:\n                total_distance += (pos_right - A[i])\n                pos_right = A[i]\n    \n    return total_distance\n\n# Read input\nimport sys\ninput_data = sys.stdin.read().split()\nif not input_data:\n    exit(0)\n\nN = int(input_data[0])\nindex = 1\nresults = []\n\nfor _ in range(N):\n    A = int(input_data[index])\n    index += 1\n    S = input_data[index]\n    index += 1\n    \n    results.append(str(min_fatigue(N, A, S)))\n\nprint(\"\\n\".join(results))"
    ]
  },
  {
    "question_id": "abc370_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    L = int(data[0])\n    R = int(data[1])\n    \n    if L == 1 and R == 0:\n        print(\"Yes\")\n    elif L == 0 and R == 1:\n        print(\"No\")\n    else:\n        print(\"Invalid\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc370_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    \n    # Initialize the first element\n    result = [1]\n    \n    for i in range(1, n + 1):\n        # Combine result[-1] with elements 1 to i\n        new_result = []\n        for j in range(i + 1):\n            if j >= i:\n                new_result.append(result[-1])\n            else:\n                new_result.append(j)\n        result = new_result\n    \n    print(result[0])\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_b",
    "code_list": [
      "def main():\n    import sys\n    \n    # Read input\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    M = int(data[1])\n    \n    # Initialize arrays\n    families = [False] * (N + 1)  # True means family has babies\n    genders = [''] * (M + 1)\n    \n    # Process each baby\n    index = 2\n    for _ in range(M):\n        family_id = int(data[index])\n        gender_char = data[index + 1]\n        index += 2\n        \n        # Check if this family already has babies\n        if not families[family_id]:\n            # This is the first baby in this family\n            families[family_id] = True\n            if gender_char == 'M':\n                genders[_ + 1] = 'Taro'\n            else:  # gender_char == 'F'\n                genders[_ + 1] = 'Kouko'  # Assuming female babies are named Kouko\n    \n    # Output results\n    for i in range(1, M + 1):\n        print(\"Yes\" if genders[i] == 'Taro' else \"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc371_a",
    "code_list": [
      "from itertools import permutations\n\n# Define the possible values for each inequality\ninequalities = {\n    'A': ['<', '>', '<'],\n    'B': ['<', '>', '<'],\n    'C': ['<', '>', '<']\n}\n\ndef find_middle_brother(ineq_A, ineq_B, ineq_C):\n    # Generate all permutations of the three inequalities\n    for perm in permutations([ineq_A, ineq_B, ineq_C]):\n        # Assign the permutation to the three brothers\n        A_ineq = perm[0]\n        B_ineq = perm[1]\n        C_ineq = perm[2]\n        \n        # Determine the relationships based on the inequalities\n        if A_ineq == '<':\n            A_younger_than_B = True\n            A_older_than_B = False\n        else:  # A_ineq == '>'\n            A_younger_than_B = False\n            A_older_than_B = True\n            \n        if B_ineq == '<':\n            B_younger_than_C = True\n            B_older_than_C = False\n        else:  # B_ineq == '>'\n            B_younger_than_C = False\n            B_older_than_C = True\n            \n        if C_ineq == '<':\n            C_younger_than_B = True\n            C_older_than_B = False\n        else:  # C_ineq == '>'\n            C_younger_than_B = False\n            C_older_than_B = True\n        \n        # Check consistency\n        if not (A_younger_than_B and B_younger_than_C and C_younger_than_B):\n            continue\n            \n        # Find the middle brother\n        if A_older_than_B and B_older_than_C:\n            return 'A'\n        elif A_older_than_B and B_younger_than_C:\n            return 'B'\n        elif A_younger_than_B and B_older_than_C:\n            return 'B'\n        elif A_younger_than_B and B_older_than_C:\n            return 'C'\n    \n    return None\n\n# Read input from stdin\nimport sys\ndata = sys.stdin.read().strip()\nif data:\n    S_AB, S_AC, S_BC = data.split()\n\nmiddle_brother = find_middle_brother(S_AB, S_AC, S_BC)\nprint(middle_brother)"
    ]
  },
  {
    "question_id": "abc372_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    result = data.replace('.', '')\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    count = 0\n    for i, s in enumerate(data):\n        if len(s) == i + 1:\n            count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc373_b",
    "code_list": [
      "def min_typing_distance(S):\n    # Create mapping from character to position\n    char_to_pos = {chr(ord('A') + i): i + 1 for i in range(26)}\n    \n    # Initialize result with distance from A (position 1)\n    result = 0\n    \n    # Calculate distance for each character\n    for char in S:\n        pos = char_to_pos[char]\n        result += abs(pos - 1)\n    \n    return result\n\n# Read input from stdin\nimport sys\ninput_data = sys.stdin.read().strip()\nprint(min_typing_distance(input_data))"
    ]
  },
  {
    "question_id": "abc374_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    s = data[0].strip()\n    t = data[1].strip()\n    \n    # Check if strings are equal\n    if s == t:\n        print(0)\n        return\n        \n    # Find the first differing character\n    for i in range(min(len(s), len(t))):\n        if s[i] != t[i]:\n            print(i + 1)  # Convert to 1-based index\n            return\n            \n    # If no differing character found (shouldn't happen according to problem statement)\n    # But just in case, print the maximum possible position\n    print(max(len(s), len(t)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc374_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if data.endswith(\"san\"):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_b",
    "code_list": [
      "import sys\nimport math\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    \n    # Initialize the first point as (0,0)\n    x, y = 0, 0\n    \n    total_distance = 0.0\n    \n    # Process all points except the last one\n    for i in range(N):\n        idx = 1 + 2 * i\n        next_x = int(data[idx])\n        next_y = int(data[idx + 1])\n        \n        dx = next_x - x\n        dy = next_y - y\n        \n        # Add the Euclidean distance between consecutive points\n        total_distance += math.sqrt(dx*dx + dy*dy)\n        \n        # Update current position\n        x, y = next_x, next_y\n    \n    # Add the distance from the last point back to the origin\n    total_distance += math.sqrt(x*x + y*y)\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc375_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    \n    count = 0\n    for i in range(N - 2):\n        if S[i] == '#' and S[i+2] == '#':\n            count += 1\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc376_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    N = int(data[0])\n    C = int(data[1])\n    \n    presses = []\n    index = 2\n    for i in range(N):\n        presses.append(int(data[index]))\n        index += 1\n        \n    # Sort the presses by time\n    presses.sort()\n    \n    count = 0\n    current_time = 0\n    \n    for t in presses:\n        if t - current_time >= C:\n            count += 1\n            current_time = t\n            \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_b",
    "code_list": [
      "def main():\n    grid = []\n    for _ in range(8):\n        grid.append(input().strip())\n    \n    count = 0\n    \n    for i in range(8):\n        for j in range(8):\n            if grid[i][j] == '.':\n                # Check all four neighbors\n                valid = True\n                \n                # Check up neighbor\n                if i > 0 and grid[i-1][j] == '#':\n                    valid = False\n                \n                # Check down neighbor\n                if i < 7 and grid[i+1][j] == '#':\n                    valid = False\n                \n                # Check left neighbor\n                if j > 0 and grid[i][j-1] == '#':\n                    valid = False\n                \n                # Check right neighbor\n                if j < 7 and grid[i][j+1] == '#':\n                    valid = False\n                \n                if valid:\n                    count += 1\n                    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc377_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    s = data.strip('\"')\n    \n    # Count frequency of each character\n    freq = {}\n    for char in s:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if we have at least one of each character\n    if len(freq) < 3:\n        print(\"No\")\n        return\n        \n    # Check if we have exactly one of each character\n    if all(count == 1 for count in freq.values()):\n        print(\"Yes\")\n        return\n        \n    # Check if we have exactly two of one character and one of another\n    counts = list(freq.values())\n    if (counts[0] == 2 and counts[1] == 1 and counts[2] == 1) or \\\n       (counts[0] == 1 and counts[1] == 2 and counts[2] == 1):\n        print(\"Yes\")\n        return\n        \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    \n    # Parse N\n    N = int(data[0])\n    \n    # Parse collection schedules\n    schedules = []\n    idx = 1\n    for _ in range(N):\n        q = int(data[idx]); r = int(data[idx+1])\n        schedules.append((q, r))\n        idx += 2\n    \n    # Parse queries\n    Q = int(data[idx])\n    queries = []\n    for _ in range(Q):\n        t = int(data[idx+1]); d = int(data[idx+2])\n        queries.append((t, d))\n        idx += 3\n    \n    # Initialize data structures\n    last_collection = [0] * (N + 1)\n    put_out_day = [0] * (N + 1)\n    \n    # Process queries\n    results = []\n    for t, d in queries:\n        # Find the type of garbage being put out\n        type_index = t - 1\n        \n        # Calculate the next collection day\n        if d == last_collection[type_index]:\n            next_day = d + 1\n        else:\n            # Determine the cycle length\n            q, r = schedules[type_index]\n            cycle_length = q - r\n            \n            # Find the remainder when d is divided by cycle_length\n            remainder = d % cycle_length\n            \n            # If remainder is 0, it means the garbage was put out on the last collection day\n            if remainder == 0:\n                next_day = d + 1\n            else:\n                next_day = d + remainder\n                \n        # Update the last collection day\n        last_collection[type_index] = next_day\n        \n        # Store the result\n        results.append(str(next_day))\n    \n    # Output all results\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc378_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    colors = list(map(int, data))\n    \n    count = {}\n    for color in colors:\n        if color not in count:\n            count[color] = 0\n        count[color] += 1\n    \n    max_count = 0\n    for freq in count.values():\n        if freq > max_count:\n            max_count = freq\n            \n    print(max_count)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc379_b",
    "code_list": [
      "def max_strawberries(N, K, S):\n    # Count initial segments\n    count = 0\n    for i in range(N - K + 1):\n        if S[i] == 'O':\n            count += 1\n    \n    # Sliding window to find longer segments\n    for i in range(1, N - K + 1):\n        if S[i - 1] == 'O' and S[i + K - 1] == 'O':\n            count += 1\n    \n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    K = int(data[1])\n    S = data[2]\n    \n    result = max_strawberries(N, K, S)\n    print(result)"
    ]
  },
  {
    "question_id": "abc379_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    if not data:\n        return\n    \n    # Convert string to integer\n    num = int(data)\n    \n    # Extract digits\n    hundreds = num // 100\n    tens = (num // 10) % 10\n    ones = num % 10\n    \n    # Form the two numbers\n    first_number = int(f\"{tens}{ones}{hundreds}\")\n    second_number = int(f\"{c}{a}{b}\")\n    \n    print(f\"{first_number} {second_number}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    n = int(data)\n    \n    # Count occurrences of each digit\n    count_1 = str(n).count('1')\n    count_2 = str(n).count('2')\n    count_3 = str(n).count('3')\n    \n    # Check conditions\n    if count_1 == 1 and count_2 == 2 and count_3 == 3:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc380_b",
    "code_list": [
      "def main():\n    import sys\n    \n    # Read input from stdin\n    data = sys.stdin.read().strip()\n    \n    # Reverse the string to get the correct order\n    reversed_s = data[::-1]\n    \n    # Initialize the result list with the last character\n    result = [int(reversed_s[-1])]\n    \n    # Remove the last character since it's already in our result\n    reversed_s = reversed_s[:-1]\n    \n    # Process characters from right to left\n    for char in reversed_s:\n        if char == '|':\n            # Previous character was '-', so add 1 to the result\n            result.append(1)\n        else:\n            # Previous character was ' ', so add int(char) to the result\n            result.append(int(char))\n    \n    # Reverse the result to get the correct order\n    result.reverse()\n    \n    # Print the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    \n    if len(s) != n:\n        print(\"No\")\n        return\n        \n    # Check if first half contains only '1'\n    first_half = s[:n//2]\n    if not all(c == '1' for c in first_half):\n        print(\"No\")\n        return\n        \n    # Check if second character is '/'\n    if s[n//2] != '/':\n        print(\"No\")\n        return\n        \n    # Check if second half contains only '2'\n    second_half = s[n//2+1:]\n    if not all(c == '2' for c in second_half):\n        print(\"No\")\n        return\n        \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc381_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().strip()\n    n = len(data)\n    \n    # Check if length is even\n    if n % 2 != 0:\n        print(\"No\")\n        return\n    \n    # Count frequency of each character\n    freq = {}\n    for char in data:\n        freq[char] = freq.get(char, 0) + 1\n    \n    # Check if all characters appear exactly twice\n    for count in freq.values():\n        if count != 2:\n            print(\"No\")\n            return\n    \n    # Check if each character appears at least once\n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        if char not in freq:\n            print(\"No\")\n            return\n    \n    # Check if each character appears exactly twice\n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        if freq[char] != 2:\n            print(\"No\")\n            return\n    \n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    D = int(data[1])\n    S = data[2]\n    \n    # Calculate the number of empty boxes remaining after D days\n    empty_boxes_remaining = N - D\n    \n    print(empty_boxes_remaining)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc382_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    d = int(data[1])\n    s = data[2]\n    \n    # Create list of indices where '@' appears\n    positions = [i+1 for i, char in enumerate(s) if char == '@']\n    \n    # If no cookies initially, return '.' * n\n    if not positions:\n        print('.......')\n        return\n    \n    # Process each day\n    result = ['.'] * n\n    for day in range(d):\n        # Find the last position eaten on this day\n        last_eaten = -1\n        for pos in positions:\n            if pos > last_eaten:\n                last_eaten = pos\n        \n        # Mark all boxes from last_eaten down to 1 as having cookies\n        for i in range(last_eaten, 0, -1):\n            result[i-1] = '@'\n    \n    print(''.join(result))\n\nif __name__ == '__main__':\n    main()"
    ]
  },
  {
    "question_id": "abc383_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    # Parse input\n    N = int(data[0])\n    times = []\n    volumes = []\n    index = 1\n    for i in range(N):\n        t = int(data[index]); v = int(data[index + 1])\n        times.append(t)\n        volumes.append(v)\n        index += 2\n    \n    # Process each time period\n    current_water = 0\n    for i in range(N - 1):\n        start_time = times[i]\n        end_time = times[i + 1]\n        \n        # Add water up to the start of the next period\n        current_water += volumes[i]\n        \n        # Simulate the leak until the next period starts\n        while current_water > 0 and current_water >= end_time - start_time:\n            current_water -= 1\n        \n        # If we reach or exceed the end time, we don't need to add more water\n        if current_water <= 0:\n            break\n    \n    # Add the last addition\n    current_water += volumes[N - 1]\n    \n    print(current_water)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_b",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    R = int(data[1])\n    \n    # Parse the remaining data: D_i and A_i\n    arcs = []\n    index = 2\n    for i in range(N):\n        D = int(data[index]); A = int(data[index+1])\n        index += 2\n        arcs.append((D, A))\n    \n    # Process each ARC\n    current_rating = R\n    for D, A in arcs:\n        if D == 1:  # Div. 1\n            if 1600 <= current_rating <= 2799:\n                current_rating += A\n        else:  # Div. 2\n            if 1200 <= current_rating <= 2399:\n                current_rating += A\n    \n    print(current_rating)\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc384_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    \n    n = int(data[0])\n    c1 = data[1]\n    c2 = data[2]\n    \n    s = data[3]\n    \n    result = []\n    for char in s:\n        if char != c1:\n            result.append(c2)\n        else:\n            result.append(char)\n            \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if len(data) < 3:\n        return\n    \n    a = int(data[0])\n    b = int(data[1])\n    c = int(data[2])\n    \n    total_sum = a + b + c\n    target = total_sum // 2\n    \n    # Check if target is even\n    if target % 2 != 0:\n        print(\"No\")\n        return\n        \n    # Try all possible group sizes\n    for i in range(1, target + 1):\n        if target % i == 0:\n            j = target // i\n            if i <= a and j <= b and i <= c and j <= c:\n                print(\"Yes\")\n                return\n                \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc385_b",
    "code_list": [
      "def main():\n    import sys\n    \n    data = sys.stdin.read().split()\n    \n    H = int(data[0])\n    W = int(data[1])\n    X = int(data[2]) - 1  # convert to 0-based indexing\n    Y = int(data[3]) - 1  # convert to 0-based indexing\n    \n    grid = []\n    index = 4\n    for _ in range(H):\n        row = list(data[index:index+W])\n        grid.append(row)\n        index += W\n    \n    T = data[-1]\n    \n    # Initialize current position and visited set\n    x, y = X, Y\n    visited = {(x, y)}\n    \n    # Directions mapping\n    directions = {'U': (-1, 0), 'D': (1, 0), 'L': (0, -1), 'R': (0, 1)}\n    \n    # Process each instruction\n    for char in T:\n        dx, dy = directions[char]\n        \n        # Check if moving in this direction would take us out of bounds\n        if 0 <= x + dx < H and 0 <= y + dy < W:\n            nx, ny = x + dx, y + dy\n            if grid[nx][ny] == '.':\n                x, y = nx, ny\n                visited.add((x, y))\n    \n    # Output the result\n    print(f\"{x+1} {y+1} {len(visited)}\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_a",
    "code_list": [
      "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    A, B, C, D = map(int, data)\n    \n    # Check if we already have a full house (all same number)\n    if A == B == C == D:\n        print(\"Yes\")\n        return\n    \n    # Try adding each possible card\n    for num in range(1, 14):\n        if num != A and num != B and num != C and num != D:\n            new_set = sorted([A, B, C, D, num])\n            if len(set(new_set)) == 3:\n                print(\"Yes\")\n                return\n                \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    main()"
    ]
  },
  {
    "question_id": "abc386_b",
    "code_list": [
      "def min_presses(S):\n    # Convert S to list of digits\n    result = []\n    \n    # Process each digit in S\n    for char in S:\n        if result and result[-1] == '0':\n            # Replace the last '0' with the current digit\n            result.pop()  # Remove the '0'\n            result.append(char)\n        else:\n            # Prepend the current digit to the beginning\n            result.insert(0, char)\n    \n    return len(result)\n\n# Read input from stdin\nimport sys\ninput_data = sys.stdin.read().strip()\nS = input_data.strip('\"')\n\n# Calculate and print the result\nprint(min_presses(S))"
    ]
  }
]